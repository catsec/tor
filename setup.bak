#!/bin/bash
#===============================================================================
# Debian 13 Security Setup Script
#===============================================================================
# 
# PURPOSE:
#   Comprehensive security hardening script for fresh Debian 13 installations.
#   Sets up SSH key authentication, creates non-root user, configures WireGuard
#   VPN with selective routing, and prepares Tor proxy access.
#
# DESIGN PHILOSOPHY:
#   - Stateful: Tracks progress and allows resuming from any step
#   - Safe: Validates dependencies and provides rollback capabilities  
#   - Flexible: Supports both sequential and individual step execution
#   - User-friendly: Clear instructions and error messages
#
# EXECUTION PHASES:
#   Phase 1 (Steps 1-5): Run as root on fresh Debian system
#   Phase 2 (Steps 6-8): Run as root OR user with sudo (via SSH connection)
#
# Usage: ./setup.sh [options]
# Options:
#   -s, --step NAME      Force execute specific step (ignores dependencies)
#   -c, --continue NAME  Continue from step NAME and update state file
#   -h, --help          Show this help message
#
# SECURITY NOTICE:
#   This script is designed for DEFENSIVE security purposes only.
#   It creates secure infrastructure for legitimate privacy and security needs.
#===============================================================================

# Exit immediately on any error - ensures script stops if something goes wrong
set -e

#===============================================================================
# CONFIGURATION SECTION
#===============================================================================

# State file location - stores completed steps and username for persistence
# Using /var/tmp because it survives reboots and is accessible to both root and users
# /var/tmp persists across reboots unlike /tmp which gets cleared
STATUS_FILE="/var/tmp/debian-setup-status"

# Global variables for command-line argument processing
FORCE_STEP=""        # Set when user forces a specific step with -s
CONTINUE_FROM=""     # Set when user wants to continue from a specific step with -c

#===============================================================================
# STEP MAPPING SYSTEM
#===============================================================================

# Associative array mapping human-readable step names to numbers
# This allows users to use memorable names instead of numbers
# Design: Makes the script more user-friendly and self-documenting
declare -A STEP_MAP=(
    ["update"]=1      # System package updates
    ["packages"]=2    # Install security packages
    ["verify"]=3      # Verify installations
    ["user"]=4        # Create non-root user
    ["ssh"]=5         # SSH hardening and key setup
    ["verifyssh"]=6   # Verify SSH connection works
    ["wireguard"]=7   # WireGuard VPN setup
    ["tor"]=8         # Tor proxy configuration
    ["site"]=9        # Hardened nginx site configuration
)

#===============================================================================
# UTILITY FUNCTIONS
#===============================================================================

# Convert human-readable step name to numeric ID
# Purpose: Allows users to use memorable names while internally using numbers
# Input: Step name (e.g., "update", "ssh")
# Output: Step number (e.g., 1, 5) or exits with error
get_step_number() {
    local step_name="$1"
    
    # Check if the step name exists in our mapping
    if [[ -n "${STEP_MAP[$step_name]}" ]]; then
        echo "${STEP_MAP[$step_name]}"
    else
        # Provide helpful error message with valid options
        echo "Invalid step: $step_name" >&2
        echo "Valid steps: update, packages, verify, user, ssh, verifyssh, wireguard, tor, site" >&2
        exit 1
    fi
}

#===============================================================================
# COMMAND LINE ARGUMENT PARSING
#===============================================================================

# Parse command line arguments using standard Unix conventions
# Design: Supports both short (-s) and long (--step) options for flexibility
while [[ $# -gt 0 ]]; do
    case $1 in
        -s|--step)
            # Force execution of a specific step
            # Purpose: Allows running individual steps for debugging or selective execution
            # Warning: Bypasses dependency checks (use with caution)
            if [[ -z "$2" ]]; then
                echo "Error: --step requires a step name" >&2
                echo "Valid steps: update, packages, verify, user, ssh, verifyssh, wireguard, tor, site" >&2
                exit 1
            fi
            FORCE_STEP=$(get_step_number "$2")
            shift 2  # Consume both the flag and its argument
            ;;
        -c|--continue)
            # Continue execution from a specific step
            # Purpose: Resume script from a particular point, useful after interruptions
            # Feature: Updates state file to reflect the new starting point
            if [[ -z "$2" ]]; then
                echo "Error: --continue requires a step name" >&2
                echo "Valid steps: update, packages, verify, user, ssh, verifyssh, wireguard, tor, site" >&2
                exit 1
            fi
            CONTINUE_FROM=$(get_step_number "$2")
            shift 2  # Consume both the flag and its argument
            ;;
        -h|--help)
            # Display comprehensive help information
            # Design: Provides both usage syntax and step descriptions for user guidance
            echo "Usage: $0 [options]"
            echo "Options:"
            echo "  -s, --step STEP    Force execute specific step (update|packages|verify|user|ssh|verifyssh|wireguard|tor|site)"
            echo "  -c, --continue STEP Continue from step and update state file"
            echo "  -h, --help         Show this help message"
            echo ""
            echo "Steps:"
            echo "  update    - Update system packages"
            echo "  packages  - Install security packages"
            echo "  verify    - Verify installations"
            echo "  user      - Create user account"
            echo "  ssh       - Setup SSH key authentication and harden SSH"
            echo "  verifyssh - Verify SSH connection is working"
            echo "  wireguard - Setup WireGuard VPN with one peer"
            echo "  tor       - Configure Tor proxy with secure settings"
            echo "  site      - Setup hardened nginx site with demo page"
            exit 0
            ;;
        *)
            # Handle invalid arguments gracefully
            echo "Unknown option: $1"
            exit 1
            ;;
    esac
done

# ============================================================================
# ROOT PRIVILEGE CHECK
# ============================================================================

# ROOT/SUDO PRIVILEGE CHECK: Ensure adequate permissions for system changes
# Steps 1-5 require root, steps 6-9 can run with sudo
# Check placed after help processing so users can see help without privileges
if [ "$(id -u)" -ne 0 ]; then
    # Check if running specific steps 6-9 that can work with sudo
    if [[ -n "$FORCE_STEP" && ("$FORCE_STEP" -eq 6 || "$FORCE_STEP" -eq 7 || "$FORCE_STEP" -eq 8 || "$FORCE_STEP" -eq 9) ]] || \
       [[ -n "$CONTINUE_FROM" && "$CONTINUE_FROM" -ge 6 ]]; then
        # For steps 6-9, check if user has sudo access
        if ! sudo -n true 2>/dev/null; then
            echo "Steps 6-9 require sudo access when not running as root" >&2
            echo "Please run: sudo $0 [options]" >&2
            echo "Or run as root for all steps" >&2
            exit 1
        fi
        echo "Running with sudo privileges for steps 6-9"
    else
        # Steps 1-5 require root
        echo "Steps 1-5 must be run as root" >&2
        echo "Please run: sudo $0 [options]" >&2
        exit 1
    fi
fi

#===============================================================================
# STATE MANAGEMENT SYSTEM
#===============================================================================

# The state management system allows the script to:
# 1. Track which steps have been completed
# 2. Store essential data (like usernames) between runs
# 3. Resume execution from any point
# 4. Prevent accidental re-execution of completed steps
#
# State file format: "step_number:additional_data" or just "step_number"
# Example: "4:myuser" means step 4 completed with username "myuser"

# Get the highest completed step number from state file
# Purpose: Determines where to resume normal execution
# Returns: Step number (0 if no state file exists)
# Example: "4:myuser" returns "4", "3" returns "3"
get_last_completed_step() {
    if [[ -f "$STATUS_FILE" ]]; then
        local status_line=$(cat "$STATUS_FILE")
        # Extract everything before the first colon (or the whole line if no colon)
        echo "${status_line%%:*}"
    else
        # No state file means no steps completed yet
        echo "0"
    fi
}

# Record completion of a step, optionally with additional data
# Purpose: Persist progress and data for future script runs
# Parameters: $1=step_number, $2=optional_data (e.g., username)
# Design: Overwrites previous state to always reflect current progress
mark_step_completed() {
    local step_num=$1
    local user_data=${2:-}  # Optional second parameter with default empty value
    
    if [[ -n "$user_data" ]]; then
        # Save step with additional data (format: "step:data")
        echo "$step_num:$user_data" > "$STATUS_FILE"
    else
        # Save step number only
        echo "$step_num" > "$STATUS_FILE"
    fi
    
    # Set readable permissions for both root and users (steps 6-7 may run as user)
    chmod 644 "$STATUS_FILE" 2>/dev/null || true
    echo "Step $step_num completed and saved to state file"
}

# Extract saved username from state file
# Purpose: Allows later steps to access username created in step 4
# Returns: Username if saved, empty string otherwise
# Example: "4:myuser" returns "myuser", "3" returns ""
get_saved_username() {
    if [[ -f "$STATUS_FILE" ]]; then
        local status_line=$(cat "$STATUS_FILE")
        # Check if line contains a colon (indicating additional data)
        if [[ "$status_line" == *":"* ]]; then
            # Extract everything after the first colon
            echo "${status_line#*:}"
        fi
    fi
    # Return empty string if no username found
}

# Detect SSH service name across different distributions
# Purpose: Handle different SSH service names (ssh vs sshd) in single function
# Returns: Service name (ssh or sshd) or exits with error if not found
detect_ssh_service() {
    if systemctl list-unit-files | grep -q "^ssh\.service"; then
        echo "ssh"
    elif systemctl list-unit-files | grep -q "^sshd\.service"; then
        echo "sshd"
    else
        echo ""
    fi
}

# Security check: Verify only expected users exist on the system
# Purpose: Detect unauthorized user accounts that could indicate compromise
# Expected users: root + script-created user only
# Warns about any additional login-capable users
check_user_security() {
    local expected_username="$1"  # The username created by this script
    local warn_only="${2:-true}"  # Default to warning only, not failing
    
    echo "Performing user security check..."
    
    # Get all users with login shells (not system accounts)
    # Login shells typically: /bin/bash, /bin/sh, /bin/zsh, /usr/bin/fish, etc.
    local login_users=()
    while IFS=: read -r username _ uid _ _ _ shell; do
        # Skip system accounts (UID < 1000) but include root (UID 0)
        if [[ "$uid" -eq 0 ]] || [[ "$uid" -ge 1000 ]]; then
            # Check if shell is a login shell (not /usr/sbin/nologin, /bin/false, etc.)
            if [[ "$shell" =~ ^/bin/(bash|sh|zsh|dash)$|^/usr/bin/(bash|fish|zsh)$ ]]; then
                login_users+=("$username")
            fi
        fi
    done < /etc/passwd
    
    # Expected users: root + our created user
    local expected_users=("root")
    if [[ -n "$expected_username" ]]; then
        expected_users+=("$expected_username")
    fi
    
    # Find unexpected users
    local unexpected_users=()
    for user in "${login_users[@]}"; do
        local is_expected=false
        for expected in "${expected_users[@]}"; do
            if [[ "$user" == "$expected" ]]; then
                is_expected=true
                break
            fi
        done
        if ! $is_expected; then
            unexpected_users+=("$user")
        fi
    done
    
    # Report findings
    if [[ ${#unexpected_users[@]} -eq 0 ]]; then
        echo "User security check passed: Only expected users found"
        echo "  Login-capable users: ${login_users[*]}"
    else
        echo "WARNING: Unexpected users detected on system!"
        echo "  Expected users: ${expected_users[*]}"
        echo "  All login users: ${login_users[*]}"
        echo "  Unexpected users: ${unexpected_users[*]}"
        echo ""
        echo "SECURITY ALERT: These additional users could indicate:"
        echo "  - System compromise or unauthorized access"
        echo "  - Default accounts not removed during setup"
        echo "  - Additional users created outside this script"
        echo ""
        echo "Please verify these accounts are legitimate and remove if necessary:"
        for user in "${unexpected_users[@]}"; do
            echo "  sudo userdel -r $user  # Remove user and home directory"
        done
        echo ""
        
        if [[ "$warn_only" != "true" ]]; then
            echo "Stopping execution due to user security concern."
            exit 1
        else
            read -p "Continue anyway? (yes/no): " continue_choice
            if [[ "$continue_choice" != "yes" ]]; then
                echo "Script stopped by user due to security concern."
                exit 0
            fi
        fi
    fi
}

# Determines if a step should run based on current state and command arguments
# Purpose: Implements smart step execution logic with dependency validation
# Arguments: step_num - the step number to evaluate (1-7)
# Returns: true (0) if step should run, false (1) if should skip
# Logic:
#   1. Force mode (--step): Runs specific step with dependency checks
#   2. Continue mode (--continue): Runs from specified step onwards
#   3. Normal mode: Runs next step in sequence only
should_run_step() {
    local step_num=$1
    local last_completed=$(get_last_completed_step)
    
    # FORCE MODE: Execute specific step (--step argument)
    # Validates dependencies to prevent broken state
    if [[ -n "$FORCE_STEP" && "$FORCE_STEP" == "$step_num" ]]; then
        # Dependency validation: prevent skipping required setup steps
        # Allow only one step ahead from current completed state
        if [[ "$step_num" -gt $((last_completed + 1)) ]]; then
            echo "Error: Cannot force step $step_num when only step $last_completed is completed"
            echo "Missing dependencies from previous steps."
            echo "Steps that need to be completed first:"
            # Show user exactly which steps they're missing
            for ((i=last_completed+1; i<step_num; i++)); do
                case $i in
                    1) echo "  - Step 1 (update): Update system packages" ;;
                    2) echo "  - Step 2 (packages): Install security packages" ;;
                    3) echo "  - Step 3 (verify): Verify installations" ;;
                    4) echo "  - Step 4 (user): Create user account" ;;
                    5) echo "  - Step 5 (ssh): Setup SSH key authentication" ;;
                    6) echo "  - Step 6 (verifyssh): Verify SSH connection is working" ;;
                    7) echo "  - Step 7 (wireguard): Setup WireGuard VPN with one peer" ;;
                    8) echo "  - Step 8 (tor): Configure Tor proxy with secure settings" ;;
                    9) echo "  - Step 9 (site): Setup hardened nginx site with demo page" ;;
                esac
            done
            echo "Please run steps in order or use --continue mode."
            exit 1
        fi
        return 0
    fi
    
    # CONTINUE MODE: Execute from specified step onwards (--continue argument)
    # More permissive than force mode - runs all steps from continue point
    if [[ -n "$CONTINUE_FROM" && "$step_num" -ge "$CONTINUE_FROM" ]]; then
        return 0
    fi
    
    # NORMAL MODE: Sequential execution - only run next step in sequence
    # This is the default behavior ensuring orderly progression
    if [[ "$step_num" -gt "$last_completed" ]]; then
        return 0
    fi
    
    # SKIP: Step already completed or not ready to run
    return 1
}

# CONTINUE MODE SETUP: Prepare state file for continue execution
# Purpose: When using --continue, we need to set the state to one step before
#          the continue point so normal execution logic works correctly
if [[ -n "$CONTINUE_FROM" ]]; then
    # SAFETY: Backup existing state file before modification
    if [[ -f "$STATUS_FILE" ]]; then
        cp "$STATUS_FILE" "${STATUS_FILE}.backup"
        echo "State file backed up to ${STATUS_FILE}.backup"
    fi
    
    # Preserve username if it exists in current state (important for steps 5-7)
    saved_username=$(get_saved_username)
    prev_step=$((CONTINUE_FROM - 1))
    
    # Edge case: continuing from step 1 should reset to step 0 (clean slate)
    if [[ "$prev_step" -lt 0 ]]; then
        prev_step=0
    fi
    
    # Update state file with preserved username or just step number
    # Special handling: if continuing from steps 5-7 and no username exists,
    # warn user but don't fail (they might be re-running after user creation)
    if [[ -n "$saved_username" ]]; then
        echo "$prev_step:$saved_username" > "$STATUS_FILE"
    else
        echo "$prev_step" > "$STATUS_FILE"
        # Warn if continuing to steps that typically need username
        if [[ "$CONTINUE_FROM" -ge 5 ]]; then
            echo "Warning: No username found in state file for steps 5-7"
            echo "If step 4 (user creation) was completed, the username should be saved"
            echo "You may need to run step 4 first if you haven't created a user"
        fi
    fi
    
    # Set accessible permissions for continue mode state file
    chmod 644 "$STATUS_FILE" 2>/dev/null || true
    echo "State file updated to continue from step $CONTINUE_FROM"
    echo "Original state backed up. Restore with: mv ${STATUS_FILE}.backup $STATUS_FILE"
fi

# ============================================================================
# EXECUTION PHASE VALIDATION
# ============================================================================


# ============================================================================
# GLOBAL SCRIPT INSTALLATION
# ============================================================================

# Install script globally for easy access from any location
# Purpose: Allows user to run 'setup.sh' from anywhere after initial setup
# This happens before any steps so the script is immediately available
copy_script_to_bin() {
    local script_path="$(realpath "$0")"
    local script_name="setup.sh"
    local bin_path="/usr/local/bin/$script_name"
    
    # Smart copying: only update if source is newer or doesn't exist
    if [[ "$script_path" != "$bin_path" ]]; then
        if [[ ! -f "$bin_path" ]] || [[ "$script_path" -nt "$bin_path" ]]; then
            echo "Copying setup script to $bin_path for global access..."
            cp "$script_path" "$bin_path"
            chmod +x "$bin_path"
            echo "Script is now available globally as 'setup.sh'"
        fi
    fi
}

# Copy script to bin directory before running any steps
copy_script_to_bin

# CRITICAL SECURITY CHECK: Verify system has only root user
# This script is designed for fresh systems - refuse to run if other users exist
echo "Performing critical security check..."

# Get all users with login shells (excluding system accounts)
login_users=()
while IFS=: read -r username _ uid _ _ _ shell; do
    # Skip system accounts (UID < 1000) but include root (UID 0)
    if [[ "$uid" -eq 0 ]] || [[ "$uid" -ge 1000 ]]; then
        # Check if shell is a login shell (not /usr/sbin/nologin, /bin/false, etc.)
        if [[ "$shell" =~ ^/bin/(bash|sh|zsh|dash)$|^/usr/bin/(bash|fish|zsh)$ ]]; then
            login_users+=("$username")
        fi
    fi
done < /etc/passwd

# Check if only root exists
non_root_users=()
for user in "${login_users[@]}"; do
    if [[ "$user" != "root" ]]; then
        non_root_users+=("$user")
    fi
done

if [[ ${#non_root_users[@]} -gt 0 ]]; then
    echo "SECURITY ERROR: System has existing users other than root!"
    echo ""
    echo "Found login-capable users: ${login_users[*]}"
    echo "Non-root users detected: ${non_root_users[*]}"
    echo ""
    echo "This script is designed for FRESH Debian 13 installations with only root."
    echo "Running on a system with existing users poses security risks:"
    echo "  - Existing users may have weak passwords or SSH keys"
    echo "  - Unknown user permissions and access levels"
    echo "  - Potential for privilege escalation attacks"
    echo "  - Cannot guarantee secure baseline configuration"
    echo ""
    echo "Please use this script ONLY on fresh installations or remove existing users:"
    for user in "${non_root_users[@]}"; do
        echo "  sudo userdel -r $user  # Remove user and home directory"
    done
    echo ""
    echo "After removing existing users, run the script again on a clean system."
    exit 1
else
    echo "Security check passed: Only root user detected"
    echo "  System is ready for secure configuration"
fi
echo ""

# ============================================================================
# SETUP STEP FUNCTIONS
# ============================================================================
# Each step is designed to be idempotent and can be run independently
# All steps validate their completion and update the state file

# STEP 1: System Update
# Purpose: Ensures system is up-to-date with latest security patches
# Critical for security setup - old packages may have vulnerabilities
update() {
    echo "Step 1: Updating package lists and upgrading system..."
    # Update package database to get latest package information
    apt update
    # Perform distribution upgrade (handles kernel updates, dependencies)
    # -y flag skips interactive prompts for automated execution
    apt dist-upgrade -y
    mark_step_completed 1
}

# STEP 2: Package Installation  
# Purpose: Install all required security and networking tools
# Package breakdown:
#   - openssh-server: SSH daemon for secure remote access
#   - ufw: Uncomplicated Firewall (installed but not configured)
#   - tor: Anonymity network daemon (runs SOCKS proxy on port 9050)
#   - nyx: Command-line monitor for tor
#   - nginx: Web server (may be used for hosting services)
#   - wireguard: Modern VPN solution with selective routing
#   - curl: HTTP client for IP detection and web requests
#   - qrencode: QR code generation for mobile WireGuard setup
packages() {
    echo "Step 2: Installing security packages..."
    # Install all packages in single command for efficiency
    # -y flag accepts all prompts automatically
    apt install -y openssh-server ufw tor nyx nginx wireguard curl qrencode
    mark_step_completed 2
}

# STEP 3: Installation Verification
# Purpose: Confirm all packages installed correctly and services are available
# This step prevents proceeding with broken installations
verify() {
    echo "Step 3: Verifying installations..."
    
    # SSH Service Detection: Use shared detection function for consistency
    SSH_SERVICE=$(detect_ssh_service)
    
    # Comprehensive verification: Check both service availability and command presence
    # Using &>/dev/null to suppress output and only check return codes
    if [[ -n "$SSH_SERVICE" ]] && systemctl is-enabled "$SSH_SERVICE" &>/dev/null && \
       command -v ufw &>/dev/null && \
       command -v tor &>/dev/null && \
       command -v nyx &>/dev/null && \
       command -v nginx &>/dev/null && \
       command -v wg &>/dev/null && \
       command -v curl &>/dev/null && \
       command -v qrencode &>/dev/null; then
        echo "All packages installed successfully"
        echo "SSH service detected as: $SSH_SERVICE"
        mark_step_completed 3
    else
        echo "Some packages failed to install properly"
        [[ -z "$SSH_SERVICE" ]] && echo "Warning: Could not detect SSH service (ssh or sshd)"
        exit 1
    fi
}

# STEP 4: User Account Creation
# Purpose: Create secure non-root user account with sudo privileges
# Security rationale: Root access should be restricted; daily operations use sudo
# The username is saved to state file for use in subsequent steps
user() {
    echo "Step 4: Creating user account..."
    read -p "Enter username: " username
    
    # USERNAME VALIDATION: Enforce Linux username standards
    # Pattern: ^[a-z][-a-z0-9]*$ means:
    #   - Must start with lowercase letter
    #   - Can contain lowercase letters, numbers, hyphens
    #   - No special characters that could cause security issues
    if [[ ! "$username" =~ ^[a-z][-a-z0-9]*$ ]]; then
        echo "Error: Username must start with a lowercase letter and contain only lowercase letters, numbers, and hyphens"
        exit 1
    fi
    
    # Length validation: 1-32 characters (standard Linux limits)
    if [[ ${#username} -lt 1 || ${#username} -gt 32 ]]; then
        echo "Error: Username must be between 1 and 32 characters long"
        exit 1
    fi
    
    # Prevent duplicate user creation
    if id "$username" &>/dev/null; then
        echo "Error: User $username already exists"
        exit 1
    fi
    
    # PASSWORD SECURITY: Enforce strong password policy with enhanced validation
    # Requirements: 12+ chars, uppercase, lowercase, number, safe characters
    # Loop until valid password is provided
    while true; do
        read -s -p "Enter password: " password
        echo
        
        # Length check
        if [[ ${#password} -lt 12 ]]; then
            echo "Password must be at least 12 characters long."
            continue
        fi
        
        # Character class checks
        if [[ ! "$password" =~ [A-Z] ]]; then
            echo "Password must include at least one uppercase letter (A-Z)."
            continue
        fi
        
        if [[ ! "$password" =~ [a-z] ]]; then
            echo "Password must include at least one lowercase letter (a-z)."
            continue
        fi
        
        if [[ ! "$password" =~ [0-9] ]]; then
            echo "Password must include at least one number (0-9)."
            continue
        fi
        
        # Check for problematic characters that could break chpasswd
        if [[ "$password" =~ [\'\"\\\$\`] ]]; then
            echo "Password cannot contain single quotes, double quotes, backslashes, dollar signs, or backticks."
            continue
        fi
        
        # Check for control characters or newlines
        if [[ "$password" =~ $'\n'|$'\r'|$'\t' ]]; then
            echo "Password cannot contain newlines, carriage returns, or tabs."
            continue
        fi
        
        # If we get here, password is valid
        break
    done
    
    # USER CREATION: Create with home directory and bash shell
    # -m: Create home directory
    # -s: Set shell to /bin/bash (more user-friendly than default)
    useradd -m -s /bin/bash "$username"
    
    # SECURE PASSWORD SETTING: Use printf to avoid shell expansion and process list exposure
    # This method is safer than echo as it doesn't expose password in process arguments
    printf '%s:%s\n' "$username" "$password" | chpasswd
    
    # SUDO PRIVILEGES: Add user to sudo group for administrative access
    # This is required for steps 6-7 which run as user with sudo
    usermod -aG sudo "$username"
    
    # VERIFICATION: Confirm sudo group membership
    if groups "$username" | grep -q sudo; then
        echo "User $username added to sudo group successfully"
    else
        echo "Failed to add user to sudo group"
        exit 1
    fi
    
    # SUDO ACCESS TEST: Verify user can actually use sudo
    # Challenge: Need to test sudo with password containing special characters
    # Solution: Use temporary script to safely pass password
    echo "Testing sudo access for user $username..."
    local temp_script=$(mktemp)
    cat > "$temp_script" << 'SCRIPT_EOF'
#!/bin/bash
printf '%s\n' "$1" | sudo -S whoami 2>/dev/null
SCRIPT_EOF
    chmod +x "$temp_script"
    
    # Test: Switch to user, run sudo command, check if returns 'root'
    if su - "$username" -c "\"$temp_script\" \"\$1\"" -- "$password" | grep -q root; then
        echo "Sudo access confirmed for user $username"
    else
        echo "Failed to confirm sudo access for user $username"
        rm -f "$temp_script"
        exit 1
    fi
    rm -f "$temp_script"
    
    echo "User $username created successfully with sudo privileges"
    
    # SECURITY CHECK: Verify only expected users exist (root + created user)
    # This helps detect any unauthorized accounts before hardening SSH
    echo ""
    check_user_security "$username" true
    echo ""
    
    # Save username to state file for use in steps 5-7
    mark_step_completed 4 "$username"
}

# STEP 5: SSH Key Authentication Setup
# Purpose: Configure SSH for secure key-based authentication and disable root login
# Security: Eliminates password-based attacks, restricts root access
# This step requires username from step 4, runs system-specific setup instructions
ssh() {
    echo "Step 5: Setting up SSH key authentication..."
    
    # VARIABLE DECLARATION: Ensure username is properly scoped
    local username=""
    
    # SSH SERVICE VALIDATION: Ensure SSH daemon is available and running
    # Use shared detection function for consistency
    SSH_SERVICE=$(detect_ssh_service)
    if [[ -z "$SSH_SERVICE" ]]; then
        echo "Error: SSH service not found. Please run steps 2 and 3 (packages and verify) first."
        exit 1
    fi
    
    # Start SSH service if not running (required for configuration)
    if ! systemctl is-active "$SSH_SERVICE" &>/dev/null; then
        echo "Warning: SSH service ($SSH_SERVICE) is not running. Starting it now..."
        systemctl start "$SSH_SERVICE"
        
        # Verify service started successfully before proceeding
        if ! systemctl is-active "$SSH_SERVICE" &>/dev/null; then
            echo "Error: Failed to start SSH service ($SSH_SERVICE)"
            exit 1
        fi
        echo "SSH service ($SSH_SERVICE) started successfully"
    fi
    
    # USERNAME DEPENDENCY: Step 5 requires username from step 4
    # Handle case where step 5 is run independently via --step or --continue
    if [[ -z "$username" ]]; then
        username=$(get_saved_username)
        if [[ -z "$username" ]]; then
            echo "Error: No username found in state file and step 5 requires a username"
            echo "Please run step 4 (user) first to create a user account, or run the full script sequence."
            exit 1
        else
            echo "Using saved username: $username"
        fi
        
        # VALIDATION: Ensure saved username is valid and user exists
        if [[ ! "$username" =~ ^[a-z][-a-z0-9]*$ ]]; then
            echo "Error: Invalid username format in state file: $username"
            echo "Please run step 4 (user) again to create a valid user account."
            exit 1
        fi
        
        # Verify user exists on system
        if ! id "$username" &>/dev/null; then
            echo "Error: User $username from state file does not exist on system"
            echo "Please run step 4 (user) again to create the user account."
            exit 1
        fi
        
        # Verify user has sudo privileges (required for steps 6-7)
        if ! groups "$username" | grep -q sudo; then
            echo "Error: User $username is not in sudo group"
            echo "Please run step 4 (user) again to ensure user has sudo privileges."
            exit 1
        fi
    fi
    
    # SERVER IP DETECTION: Determine local IP address for SSH instructions
    # Uses multiple fallback methods for reliability across different systems
    # Note: This gets LOCAL IP, not public IP (appropriate for SSH setup)
    SERVER_IP=""
    
    # Method 1: Use ip route command (most reliable on modern Linux)
    # Gets IP that would be used to reach 1.1.1.1 (reliable external target)
    if command -v ip >/dev/null 2>&1; then
        SERVER_IP=$(ip route get 1.1.1.1 2>/dev/null | awk '/src/ {print $7; exit}')
    fi
    
    # Method 2: Use hostname -I (backup method)
    if [[ -z "$SERVER_IP" ]]; then
        SERVER_IP=$(hostname -I 2>/dev/null | awk '{print $1}')
    fi
    
    # Method 3: Use hostname -i (older systems)
    if [[ -z "$SERVER_IP" ]]; then
        SERVER_IP=$(hostname -i 2>/dev/null | awk '{print $1}')
    fi
    
    # Method 4: Manual input if all automatic methods fail
    if [[ -z "$SERVER_IP" ]]; then
        echo "Warning: Could not determine server IP address automatically"
        while true; do
            read -p "Please enter the server IP address: " SERVER_IP
            # IPv4 validation: Check format and octet ranges
            if [[ "$SERVER_IP" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; then
                # Validate each octet is 0-255
                local valid=true
                IFS='.' read -ra OCTETS <<< "$SERVER_IP"
                for octet in "${OCTETS[@]}"; do
                    if [[ "$octet" -gt 255 ]]; then
                        valid=false
                        break
                    fi
                done
                if $valid; then
                    break
                fi
            fi
            echo "Error: Please enter a valid IPv4 address (e.g., 192.168.1.100)"
        done
    fi
    
    # SYSTEM-SPECIFIC SSH SETUP: Provide tailored instructions for each OS
    # Different operating systems have different SSH key generation methods
    echo "Please select your client system:"
    echo "1) Linux"
    echo "2) macOS" 
    echo "3) Windows"
    read -p "Enter choice (1-3): " system_choice
    
    # SYSTEM SELECTION: Map user choice to system identifier
    case $system_choice in
        1)
            client_system="linux"
            ;;
        2)
            client_system="macos"
            ;;
        3)
            client_system="windows"
            ;;
        *)
            echo "Invalid choice. Exiting."
            exit 1
            ;;
    esac
    
    # DISPLAY SYSTEM-SPECIFIC INSTRUCTIONS
    # Each OS requires different methods for SSH key generation and deployment
    echo ""
    echo "=== SSH Key Setup Instructions for $client_system ==="
    echo ""
    
    case $client_system in
        "linux"|"macos")
            # Unix-like systems: Standard OpenSSH tools available
            echo "On your $client_system machine, run these commands:"
            echo ""
            echo "1. Generate SSH key pair:"
            echo "   ssh-keygen -t ed25519 -C \"your-email@example.com\""
            echo "   (Press Enter to accept default location, optionally set passphrase)"
            echo ""
            echo "2. Copy public key to server:"
            echo "   ssh-copy-id $username@$SERVER_IP"
            echo ""
            echo "3. Test connection:"
            echo "   ssh $username@$SERVER_IP"
            ;;
        "windows")
            # Windows: Multiple options depending on Windows version and user preference
            echo "On your Windows machine:"
            echo ""
            echo "Option A - Using PowerShell (Windows 10+):"
            echo "1. Generate SSH key pair:"
            echo "   ssh-keygen -t ed25519 -C \"your-email@example.com\""
            echo ""
            echo "2. Copy public key to server:"
            echo "   type \$env:USERPROFILE\\.ssh\\id_ed25519.pub | ssh $username@$SERVER_IP \"mkdir -p ~/.ssh && cat >> ~/.ssh/authorized_keys\""
            echo ""
            echo "Option B - Using PuTTY:"
            echo "1. Download and install PuTTY and PuTTYgen"
            echo "2. Use PuTTYgen to generate an SSH key pair"
            echo "3. Save private key and copy public key text"
            echo "4. Connect to server with current credentials and run:"
            echo "   mkdir -p ~/.ssh"
            echo "   chown $username:$username ~/.ssh"
            echo "   chmod 700 ~/.ssh"
            echo "   echo 'PASTE_PUBLIC_KEY_HERE' >> ~/.ssh/authorized_keys"
            echo "   chown $username:$username ~/.ssh/authorized_keys"
            echo "   chmod 600 ~/.ssh/authorized_keys"
            echo ""
            echo "5. Test connection with PuTTY using the private key"
            ;;
    esac
    
    # SECURITY NOTICE: Explain what hardening will occur
    # Important to warn user before making security changes
    echo ""
    echo "After setting up your SSH key, this script will:"
    echo "- Disable SSH password authentication"
    echo "- Disable root SSH login"
    echo "- Restart SSH service"
    echo ""
    echo "IMPORTANT: Ensure you can connect via SSH key BEFORE continuing!"
    echo "Test your connection first, then return here."
    echo ""
    
    # USER CONFIRMATION: Require explicit confirmation before security lockdown
    # This prevents accidental lockout from the server
    read -p "Have you successfully set up SSH key authentication and tested it? (yes/no): " ssh_confirmed
    
    if [[ "$ssh_confirmed" != "yes" ]]; then
        echo "Please set up SSH key authentication first, then run: setup.sh -c ssh"
        exit 0
    fi
    
    # SSH HARDENING: Apply secure configuration settings
    # This configuration eliminates password-based attacks
    echo "Hardening SSH configuration..."
    
    # Backup original configuration (safety measure)
    cp /etc/ssh/sshd_config /etc/ssh/sshd_config.backup
    
    # Apply SSH hardening settings
    cat > /etc/ssh/sshd_config << EOF
# SSH Hardened Configuration
Port 22

# Authentication
PermitRootLogin no
PasswordAuthentication no
PermitEmptyPasswords no
ChallengeResponseAuthentication no
UsePAM yes

# Key-based authentication only
PubkeyAuthentication yes
AuthorizedKeysFile .ssh/authorized_keys

# Security settings
X11Forwarding no
PrintMotd no
ClientAliveInterval 300
ClientAliveCountMax 2
MaxAuthTries 3
MaxSessions 2

# Allow only specific users
AllowUsers $username

# Logging
SyslogFacility AUTH
LogLevel INFO
EOF
    
    # Test SSH configuration
    if sshd -t; then
        echo "SSH configuration is valid"
        systemctl restart "$SSH_SERVICE"
        
        # Verify SSH service restarted successfully
        if ! systemctl is-active "$SSH_SERVICE" &>/dev/null; then
            echo "Error: SSH service ($SSH_SERVICE) failed to start after configuration change"
            cp /etc/ssh/sshd_config.backup /etc/ssh/sshd_config
            systemctl restart "$SSH_SERVICE"
            exit 1
        fi
        echo "SSH service ($SSH_SERVICE) restarted with hardened configuration"
        echo ""
        echo "SSH hardening completed:"
        echo "- Password authentication disabled"
        echo "- Root login disabled"
        echo "- Only key-based authentication allowed"
        echo "- Only user '$username' can connect"
        echo ""
        echo "SSH hardening completed successfully."
        echo "Connection command: ssh $username@$SERVER_IP"
        echo ""
        echo "IMPORTANT: You must now reconnect via SSH to continue the setup."
        echo "After connecting via SSH, run: sudo setup.sh"
        echo "The script will continue with step 6 (verifyssh) to verify the SSH connection."
        mark_step_completed 5
        exit 0
    else
        echo "SSH configuration test failed! Restoring backup..."
        cp /etc/ssh/sshd_config.backup /etc/ssh/sshd_config
        echo "Original SSH configuration restored"
        exit 1
    fi
}

# STEP 6: SSH Connection Verification
# Purpose: Confirm SSH key authentication is working properly
# Security: Validates that user can connect via SSH before system locks down
# This step MUST be run over SSH connection to prove keys work
verifyssh() {
    echo "Step 6: Verifying SSH connection..."
    
    # SSH CONNECTION CHECK: Ensure this step runs over SSH
    # Environment variables SSH_CLIENT and SSH_TTY are set when connected via SSH
    # This validation prevents users from accidentally locking themselves out
    if [[ -z "$SSH_CLIENT" && -z "$SSH_TTY" ]]; then
        echo "Error: You are not connected via SSH"
        echo "This step must be run over an SSH connection to verify the SSH setup is working."
        echo ""
        echo "Please connect via SSH first:"
        
        # Provide username-specific instructions if available
        local saved_username=$(get_saved_username)
        if [[ -n "$saved_username" ]]; then
            echo "  ssh $saved_username@<SERVER_IP>"
        else
            echo "  ssh <username>@<SERVER_IP>"
        fi
        echo ""
        echo "Then run this command to continue:"
        echo "  sudo setup.sh -c verifyssh"
        echo ""
        echo "If SSH connection fails, please repeat step 5 (ssh) as root:"
        echo "  sudo setup.sh -s ssh"
        exit 1
    fi
    
    # SUCCESS CONFIRMATION: Show connection details
    echo "SSH connection verified successfully!"
    echo "You are connected via SSH from: ${SSH_CLIENT%% *}"
    echo ""
    
    # CONFIGURATION VERIFICATION: Confirm hardening settings are active
    # Double-check that security settings from step 5 are properly applied
    if grep -q "^PasswordAuthentication no" /etc/ssh/sshd_config 2>/dev/null; then
        echo "SSH hardening confirmed: Password authentication is disabled"
    else
        echo "Warning: SSH configuration may not be properly hardened"
    fi
    
    # Verify root login restriction
    if grep -q "^PermitRootLogin no" /etc/ssh/sshd_config 2>/dev/null; then
        echo "SSH hardening confirmed: Root login is disabled"
    else
        echo "Warning: Root login may not be properly disabled"
    fi
    
    echo ""
    echo "SSH verification completed successfully!"
    echo "Your SSH key authentication is working and the server is properly secured."
    
    # SECURITY CHECK: Final user verification after SSH hardening
    # This is the last chance to detect unauthorized users before VPN setup
    echo ""
    local saved_username=$(get_saved_username)
    if [[ -n "$saved_username" ]]; then
        check_user_security "$saved_username" true
    else
        # If no username saved, check for any non-root users
        check_user_security "" true
    fi
    echo ""
    
    mark_step_completed 6
}

# STEP 7: WireGuard VPN Setup
# Purpose: Configure WireGuard VPN with selective routing (not full tunnel)
# Routing: Only SOCKS proxy port 9050 and SSH port 22 go through VPN
# Network: Uses 10.11.12.x range for VPN clients
# Security: Generates unique server and client keys for secure communication
wireguard() {
    echo "Step 7: Setting up WireGuard VPN..."
    
    # DEPENDENCY CHECK: Ensure WireGuard tools are available
    if ! command -v wg &>/dev/null; then
        echo "Error: WireGuard not found. Please run steps 2 and 3 (packages and verify) first."
        exit 1
    fi
    
    # CONFIGURATION PATHS: Define all WireGuard-related file locations
    local wg_dir="/etc/wireguard"
    local server_conf="$wg_dir/wg0.conf"
    local server_key="$wg_dir/server_private.key"
    local server_pub="$wg_dir/server_public.key"
    local client_key="$wg_dir/client_private.key"
    local client_pub="$wg_dir/client_public.key"
    
    # DIRECTORY SETUP: Create secure WireGuard configuration directory
    # 700 permissions ensure only root can access VPN configuration
    mkdir -p "$wg_dir"
    chmod 700 "$wg_dir"
    
    # KEY SAFETY CHECK: Prevent overwriting existing keys without user consent
    local keys_exist=false
    local existing_files=()
    
    for keyfile in "$server_key" "$server_pub" "$client_key" "$client_pub" "$server_conf"; do
        if [[ -f "$keyfile" ]]; then
            keys_exist=true
            existing_files+=("$keyfile")
        fi
    done
    
    if $keys_exist; then
        echo "WARNING: Existing WireGuard configuration detected!"
        echo "The following files already exist:"
        for file in "${existing_files[@]}"; do
            echo "  - $file"
        done
        echo ""
        echo "Continuing will overwrite these files and invalidate existing client configurations."
        read -p "Do you want to continue and overwrite existing WireGuard setup? (yes/no): " overwrite_confirm
        
        if [[ "$overwrite_confirm" != "yes" ]]; then
            echo "WireGuard setup cancelled to preserve existing configuration."
            echo "To force overwrite, run: sudo setup.sh -s wireguard"
            exit 0
        fi
        
        echo "Backing up existing files..."
        for file in "${existing_files[@]}"; do
            cp "$file" "${file}.backup.$(date +%Y%m%d_%H%M%S)"
            echo "Backed up: $file"
        done
    fi
    
    echo "Generating WireGuard keys..."
    
    # KEY GENERATION: Create cryptographic keys for server-client authentication
    # WireGuard uses Curve25519 for key exchange and ChaCha20Poly1305 for encryption
    
    # Server key pair generation
    wg genkey > "$server_key"
    chmod 600 "$server_key"  # Secure private key permissions
    wg pubkey < "$server_key" > "$server_pub"
    
    # Client key pair generation  
    wg genkey > "$client_key"
    chmod 600 "$client_key"  # Secure private key permissions
    wg pubkey < "$client_key" > "$client_pub"
    
    # Load keys into variables for configuration generation
    local server_private=$(cat "$server_key")
    local server_public=$(cat "$server_pub")
    local client_private=$(cat "$client_key")
    local client_public=$(cat "$client_pub")
    
    echo "Keys generated successfully!"
    
    # PUBLIC IP DETECTION: Get server's real public IP for WireGuard endpoint
    # Important: WireGuard needs public IP, not local IP (unlike SSH setup)
    echo "Detecting server's public IP address..."
    local server_ip=""
    
    # DEPENDENCY CHECK: Ensure curl is available for web-based IP detection
    if ! command -v curl >/dev/null 2>&1; then
        echo "Error: curl not found. Please run steps 2 and 3 (packages and verify) first."
        exit 1
    fi
    
    # MULTI-SERVICE APPROACH: Try multiple IP detection services for reliability
    # Using multiple services ensures we get accurate public IP even if one fails
    local ip_services=(
        "https://ipv4.icanhazip.com"    # Clean IPv4-only service
        "https://api.ipify.org"         # Simple IP API
        "https://ifconfig.me/ip"        # Traditional service
        "https://checkip.amazonaws.com" # AWS-backed service
    )
    
    # Try each service until we get a valid IP address
    for service in "${ip_services[@]}"; do
        # Timeout settings prevent hanging on unresponsive services
        server_ip=$(curl -s --connect-timeout 5 --max-time 10 "$service" 2>/dev/null | tr -d '\n\r' | grep -E '^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$')
        
        if [[ -n "$server_ip" ]]; then
            echo "Public IP detected: $server_ip (via external service)"
            break
        fi
    done
    
    # FALLBACK: Use local detection if all external services fail
    # Note: This may not give the correct public IP if behind NAT
    if [[ -z "$server_ip" ]]; then
        echo "Warning: Could not detect public IP from external services"
        echo "Trying local IP detection as fallback..."
        
        if command -v ip >/dev/null 2>&1; then
            server_ip=$(ip route get 1.1.1.1 2>/dev/null | awk '/src/ {print $7; exit}')
        fi
        if [[ -z "$server_ip" ]]; then
            server_ip=$(hostname -I 2>/dev/null | awk '{print $1}')
        fi
        if [[ -z "$server_ip" ]]; then
            server_ip=$(hostname -i 2>/dev/null | awk '{print $1}')
        fi
        
        if [[ -n "$server_ip" ]]; then
            echo "Warning: Using local IP ($server_ip) - this may not work for external clients"
        fi
    fi
    
    # MANUAL FALLBACK: If all automatic detection methods fail
    if [[ -z "$server_ip" ]]; then
        echo "============================================================"
        echo "MANUAL IP CONFIGURATION REQUIRED"
        echo "============================================================"
        echo "Could not automatically detect server's public IP address."
        echo ""
        echo "To find your public IP, try one of these methods:"
        echo "1. Visit whatismyipaddress.com in a browser"
        echo "2. Ask your VPS provider"
        echo "3. Check your router/firewall configuration"
        echo ""
        echo "IMPORTANT: This must be your PUBLIC IP address that clients"
        echo "           can reach from the internet, not a local IP."
        echo "============================================================"
        
        while true; do
            read -p "Please enter the server's PUBLIC IP address: " server_ip
            
            # Enhanced IP validation with better error messages
            if [[ "$server_ip" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; then
                local valid=true
                IFS='.' read -ra OCTETS <<< "$server_ip"
                for octet in "${OCTETS[@]}"; do
                    if [[ "$octet" -gt 255 || "$octet" -lt 0 ]]; then
                        valid=false
                        break
                    fi
                done
                
                # Additional check for obviously invalid ranges
                local first_octet="${OCTETS[0]}"
                if [[ "$first_octet" -eq 0 || "$first_octet" -eq 127 ]]; then
                    echo "Error: IP address $server_ip appears to be invalid"
                    echo "First octet cannot be 0 or 127"
                    continue
                fi
                
                # Warn about private IP ranges
                if [[ ("$first_octet" -eq 10) || \
                      ("$first_octet" -eq 172 && "${OCTETS[1]}" -ge 16 && "${OCTETS[1]}" -le 31) || \
                      ("$first_octet" -eq 192 && "${OCTETS[1]}" -eq 168) ]]; then
                    echo "Warning: $server_ip appears to be a private IP address."
                    read -p "Are you sure this is your PUBLIC IP? (yes/no): " confirm
                    if [[ "$confirm" != "yes" ]]; then
                        continue
                    fi
                fi
                
                if $valid; then
                    break
                fi
            fi
            echo "Error: Please enter a valid IPv4 address (e.g., 203.0.113.1)"
        done
    fi
    
    echo "Creating WireGuard server configuration..."
    
    # Create server configuration
    cat > "$server_conf" << EOF
[Interface]
PrivateKey = $server_private
Address = 10.11.12.1/24
ListenPort = 51820
PostUp = iptables -A FORWARD -i wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
PostDown = iptables -D FORWARD -i wg0 -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE

[Peer]
PublicKey = $client_public
AllowedIPs = 10.11.12.2/32
EOF
    
    chmod 600 "$server_conf"
    
    echo "Enabling IP forwarding..."
    echo 'net.ipv4.ip_forward=1' >> /etc/sysctl.conf
    sysctl -p
    
    echo "Starting WireGuard service..."
    systemctl enable wg-quick@wg0
    systemctl start wg-quick@wg0
    
    # Verify WireGuard is running
    if systemctl is-active wg-quick@wg0 &>/dev/null; then
        echo "WireGuard service started successfully!"
    else
        echo "Error: Failed to start WireGuard service"
        exit 1
    fi
    
    echo ""
    echo "========================================"
    echo "       WIREGUARD SETUP COMPLETE"
    echo "========================================"
    echo ""
    echo "Server Configuration:"
    echo "- Interface: wg0"
    echo "- Server IP: 10.11.12.1/24"
    echo "- Listen Port: 51820"
    echo "- Public IP: $server_ip (detected from external service)"
    echo ""
    echo "========================================"
    echo "        CLIENT CONFIGURATION"
    echo "========================================"
    echo ""
    echo "This is a SELECTIVE routing VPN - only specific traffic goes through the tunnel."
    echo "Save this configuration to a file (e.g., client.conf):"
    echo ""
    echo "[Interface]"
    echo "PrivateKey = $client_private"
    echo "Address = 10.11.12.2/32"
    echo ""
    echo "[Peer]"
    echo "PublicKey = $server_public"
    echo "Endpoint = $server_ip:51820"
    echo "AllowedIPs = 10.11.12.1/32"
    echo "PersistentKeepalive = 25"
    echo ""
    
    # Ask user if they want to see QR code
    read -p "Do you want to display a QR code for mobile setup? (yes/no): " show_qr
    
    if [[ "$show_qr" == "yes" || "$show_qr" == "y" ]]; then
        # Generate QR code for mobile devices
        echo ""
        echo "========================================"
        echo "           QR CODE FOR MOBILE"
        echo "========================================"
        echo ""
        echo "Scan this QR code with your mobile WireGuard app:"
        echo ""
        
        # Create client config string for QR code
        local client_config="[Interface]
PrivateKey = $client_private
Address = 10.11.12.2/32

[Peer]
PublicKey = $server_public
Endpoint = $server_ip:51820
AllowedIPs = 10.11.12.1/32
PersistentKeepalive = 25"
        
        # Generate QR code using qrencode
        if command -v qrencode >/dev/null 2>&1; then
            echo "$client_config" | qrencode -t ANSIUTF8
            echo ""
        else
            echo "QR code generation not available (qrencode not installed)"
        fi
        echo "========================================"
    fi
    echo "     CLIENT SETUP INSTRUCTIONS"
    echo "========================================"
    echo ""
    echo "1. Install WireGuard on your client device:"
    echo "   - Windows/macOS: Download from https://www.wireguard.com/install/"
    echo "   - Linux: apt install wireguard (or equivalent)"
    echo "   - Mobile: Install WireGuard app from app store"
    echo ""
    echo "2. Import the configuration above or create a file with it"
    echo ""
    echo "3. Connect to the VPN using your WireGuard client"
    echo ""
    echo "4. Configure your applications to use the WireGuard tunnel:"
    echo "   - SOCKS Proxy: Use 10.11.12.1:9050 for Tor traffic"
    echo "   - SSH: Connect to 10.11.12.1:22 for secure shell access"
    echo "   - Only these specific services route through the VPN tunnel"
    echo ""
    echo "========================================"
    echo "       FIREWALL CONFIGURATION NOTE"
    echo "========================================"
    echo ""
    echo "UFW firewall is installed but not configured."
    echo "A future step will handle UFW configuration."
    echo ""
    
    mark_step_completed 7
}

# STEP 8: Tor Proxy Configuration
# Purpose: Configure Tor for secure, anonymous web browsing and proxy services
# Network: Runs SOCKS proxy on port 9050, control port on 9051
# Security: Configured with hardened settings for maximum anonymity
tor() {
    echo "Step 8: Configuring Tor proxy..."
    
    # DEPENDENCY CHECK: Ensure Tor is installed
    if ! command -v tor &>/dev/null; then
        echo "Error: Tor not found. Please run steps 2 and 3 (packages and verify) first."
        exit 1
    fi
    
    # BACKUP EXISTING CONFIGURATION: Safety measure
    if [[ -f /etc/tor/torrc ]]; then
        cp /etc/tor/torrc /etc/tor/torrc.backup.$(date +%Y%m%d_%H%M%S)
        echo "Existing Tor configuration backed up"
    fi
    
    echo "Creating secure Tor configuration..."
    
    # HARDENED TOR CONFIGURATION: Security-focused settings with WireGuard and hidden services
    cat > /etc/tor/torrc << 'EOF'
# Tor Configuration - Security Hardened with WireGuard Support
# Generated by Debian Security Setup Script

## Basic Configuration
User debian-tor
PidFile /var/run/tor/tor.pid
Log notice file /var/log/tor/log
DataDirectory /var/lib/tor

## Network Configuration
# SOCKS proxy accessible from localhost and WireGuard clients
SocksPort 127.0.0.1:9050 IsolateDestAddr IsolateDestPort
SocksPort 10.11.12.1:9050 IsolateDestAddr IsolateDestPort
# Control port with cookie authentication for nyx
ControlPort 127.0.0.1:9051
CookieAuthentication 1
CookieAuthFileGroupReadable 1

## Hidden Services
# Nginx web server hidden service
HiddenServiceDir /var/lib/tor/nginx_hidden_service/
HiddenServicePort 80 127.0.0.1:80
HiddenServiceVersion 3

# SSH hidden service
HiddenServiceDir /var/lib/tor/ssh_hidden_service/
HiddenServicePort 22 127.0.0.1:22
HiddenServiceVersion 3

## Security Settings
# Reject all single-hop relays
AllowSingleHopCircuits 0

# Don't allow applications to connect to non-Tor network
EnforceDistinctSubnets 1

# Use only stable, fast relays
StrictNodes 1
FascistFirewall 1
ReachableAddresses *:80,*:443

## Privacy Settings
# Disable DNS leaks
DNSPort 127.0.0.1:9053
AutomapHostsOnResolve 1
AutomapHostsSuffixes .onion,.exit

# Circuit isolation for better anonymity
IsolateDestAddr 1
IsolateDestPort 1

## Performance Settings
# Speed up circuits
CircuitBuildTimeout 30
LearnCircuitBuildTimeout 0

# Connection limits
ConnLimit 1000
MaxClientCircuitsPending 32

## Logging (minimal for privacy)
Log notice syslog
SafeLogging 1

## Disable features that could reduce anonymity
# Disable bridge usage (for standard setup)
UseBridges 0

# Disable GeoIP for additional privacy
GeoIPFile
GeoIPv6File

## Exit policy (client only - no exit traffic)
ExitPolicy reject *:*
EOF

    # SET PROPER PERMISSIONS: Tor requires specific ownership
    chown debian-tor:debian-tor /etc/tor/torrc
    chmod 644 /etc/tor/torrc
    
    # CONFIGURE TOR USER AND DIRECTORIES
    echo "Setting up Tor service directories..."
    
    # Ensure Tor data directory exists with correct permissions
    mkdir -p /var/lib/tor
    chown debian-tor:debian-tor /var/lib/tor
    chmod 700 /var/lib/tor
    
    # Ensure Tor log directory exists
    mkdir -p /var/log/tor
    chown debian-tor:adm /var/log/tor
    chmod 750 /var/log/tor
    
    # Ensure Tor run directory exists
    mkdir -p /var/run/tor
    chown debian-tor:debian-tor /var/run/tor
    chmod 755 /var/run/tor
    
    # Create hidden service directories
    echo "Setting up hidden service directories..."
    mkdir -p /var/lib/tor/nginx_hidden_service
    mkdir -p /var/lib/tor/ssh_hidden_service
    chown -R debian-tor:debian-tor /var/lib/tor/nginx_hidden_service
    chown -R debian-tor:debian-tor /var/lib/tor/ssh_hidden_service
    chmod 700 /var/lib/tor/nginx_hidden_service
    chmod 700 /var/lib/tor/ssh_hidden_service
    
    echo "Starting Tor service..."
    
    # START AND ENABLE TOR SERVICE
    systemctl enable tor
    systemctl restart tor
    
    # Verify Tor is running
    sleep 3  # Give Tor time to start
    if systemctl is-active tor &>/dev/null; then
        echo "Tor service started successfully!"
    else
        echo "Error: Failed to start Tor service"
        echo "Checking Tor status..."
        systemctl status tor --no-pager -l
        exit 1
    fi
    
    # VERIFY TOR FUNCTIONALITY: Test SOCKS proxy
    echo "Testing Tor connectivity..."
    
    if command -v curl >/dev/null 2>&1; then
        # Test if we can connect through Tor
        echo "Testing anonymous connection through Tor..."
        
        # Try to get IP through Tor (with timeout)
        tor_ip=$(timeout 15 curl -s --socks5-hostname 127.0.0.1:9050 https://check.torproject.org/api/ip 2>/dev/null | grep -o '"IsTor":true' || echo "")
        
        if [[ -n "$tor_ip" ]]; then
            echo "Tor connectivity test successful!"
            echo "Anonymous browsing is working"
        else
            echo "Tor connectivity test inconclusive (may need time to build circuits)"
            echo "   Tor service is running, circuits may still be building"
        fi
    else
        echo "Tor service is running (curl not available for connectivity test)"
    fi
    
    # FIREWALL NOTE: UFW will be configured in a future step
    echo "UFW firewall configuration will be handled in a future step."
    echo "Tor ports (9050, 9051, 9053) are localhost-only by default."
    
    echo ""
    echo "========================================"
    echo "         TOR SETUP COMPLETE"
    echo "========================================"
    echo ""
    echo "Tor Configuration:"
    echo "- SOCKS Proxy: 127.0.0.1:9050 (localhost)"
    echo "- SOCKS Proxy: 10.11.12.1:9050 (WireGuard clients)"
    echo "- Control Port: 127.0.0.1:9051 (with cookie auth)"
    echo "- DNS Port: 127.0.0.1:9053"
    echo "- Log File: /var/log/tor/log"
    echo ""
    echo "Hidden Services:"
    echo "- Nginx (port 80): /var/lib/tor/nginx_hidden_service/hostname"
    echo "- SSH (port 22): /var/lib/tor/ssh_hidden_service/hostname"
    echo ""
    echo "To view hidden service addresses:"
    echo "- Nginx: sudo cat /var/lib/tor/nginx_hidden_service/hostname"
    echo "- SSH: sudo cat /var/lib/tor/ssh_hidden_service/hostname"
    echo ""
    echo "Cookie Authentication (for nyx):"
    echo "- Cookie file: /var/lib/tor/control_auth_cookie"
    echo "- Run nyx: sudo -u debian-tor nyx"
    echo "- Alternative: Add user to debian-tor group: sudo usermod -aG debian-tor \$USER"
    echo ""
    echo "Usage Examples:"
    echo "- Browse with curl: curl --socks5-hostname 127.0.0.1:9050 https://example.com"
    echo "- WireGuard client: curl --socks5-hostname 10.11.12.1:9050 https://example.com"
    echo "- Check Tor status: systemctl status tor"
    echo "- View Tor logs: sudo tail -f /var/log/tor/log"
    echo "- Test Tor: curl --socks5-hostname 127.0.0.1:9050 https://check.torproject.org"
    echo ""
    echo "Browser Configuration:"
    echo "- SOCKS Host: 127.0.0.1 (or 10.11.12.1 via WireGuard)"
    echo "- SOCKS Port: 9050"
    echo "- SOCKS Version: 5"
    echo "- DNS through SOCKS: Enable"
    echo ""
    echo "Security Notes:"
    echo "- Tor is configured for maximum anonymity"
    echo "- All traffic is isolated and encrypted"
    echo "- DNS requests go through Tor (no leaks)"
    echo "- No exit relay functionality (client only)"
    echo "- Hidden services use v3 addresses for enhanced security"
    echo ""
    
    mark_step_completed 8
}

# STEP 9: Hardened Nginx Site Configuration
# Purpose: Replace default nginx site with hardened demo page
# Security: Serves only index.html, no directory traversal, localhost only
# Content: Black background with centered white "Welcome to the dark net" text
site() {
    echo "Step 9: Setting up hardened nginx site..."
    
    # DEPENDENCY CHECK: Ensure nginx is installed
    if ! command -v nginx &>/dev/null; then
        echo "Error: nginx not found. Please run steps 2 and 3 (packages and verify) first."
        exit 1
    fi
    
    # HARDENED NGINX CONFIGURATION
    echo "Creating hardened nginx configuration..."
    
    # Backup existing configuration
    if [[ -f /etc/nginx/sites-available/default ]]; then
        cp /etc/nginx/sites-available/default /etc/nginx/sites-available/default.backup.$(date +%Y%m%d_%H%M%S)
        echo "Existing nginx configuration backed up"
    fi
    
    # Create hardened site configuration
    cat > /etc/nginx/sites-available/default << 'EOF'
# Hardened nginx configuration - localhost only
# Generated by Debian Security Setup Script

server {
    # Listen only on localhost port 80
    listen 127.0.0.1:80 default_server;
    
    # Server identification
    server_name _;
    
    # Document root
    root /var/www/html;
    index index.html;
    
    # Security headers
    add_header X-Frame-Options "DENY" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "no-referrer" always;
    add_header Content-Security-Policy "default-src 'self'; style-src 'unsafe-inline'" always;
    
    # Disable server tokens
    server_tokens off;
    
    # Main location - serve only index.html
    location = / {
        try_files /index.html =404;
    }
    
    # Serve index.html directly
    location = /index.html {
        add_header Cache-Control "no-cache, no-store, must-revalidate" always;
        add_header Pragma "no-cache" always;
        add_header Expires "0" always;
    }
    
    # Deny all other requests
    location / {
        return 404;
    }
    
    # Security: Block common attack patterns
    location ~ /\. {
        deny all;
        access_log off;
        log_not_found off;
    }
    
    location ~ ~$ {
        deny all;
        access_log off;
        log_not_found off;
    }
    
    # Block PHP execution
    location ~ \.php$ {
        deny all;
        access_log off;
        log_not_found off;
    }
    
    # Block common files
    location ~ \.(htaccess|htpasswd|ini|log|sh|sql|conf)$ {
        deny all;
        access_log off;
        log_not_found off;
    }
    
    # Disable access logs for 404s
    log_not_found off;
}
EOF
    
    # Create the demo page
    echo "Creating hardened demo page..."
    
    cat > /var/www/html/index.html << 'EOF'
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dark Net Portal</title>
    <style>
        body {
            background-color: #000000;
            color: #ffffff;
            font-family: 'Courier New', monospace;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
        }
        .container {
            font-size: 2.5em;
            font-weight: bold;
            text-shadow: 0 0 10px #ffffff;
            animation: glow 2s infinite alternate;
        }
        @keyframes glow {
            from { text-shadow: 0 0 10px #ffffff; }
            to { text-shadow: 0 0 20px #ffffff, 0 0 30px #ffffff; }
        }
    </style>
</head>
<body>
    <div class="container">
        WELCOME TO THE DARK NET
    </div>
</body>
</html>
EOF
    
    # Set proper permissions
    chown -R www-data:www-data /var/www/html
    chmod 644 /var/www/html/index.html
    chmod 755 /var/www/html
    
    # Remove any other files in web root for security
    find /var/www/html -type f ! -name "index.html" -delete 2>/dev/null || true
    
    # Test nginx configuration
    if nginx -t; then
        echo "Nginx configuration is valid"
        
        # Enable and start nginx service
        systemctl enable nginx
        systemctl restart nginx
        
        # Verify nginx is running
        if systemctl is-active nginx &>/dev/null; then
            echo "Nginx service started successfully!"
        else
            echo "Error: Failed to start nginx service"
            exit 1
        fi
    else
        echo "Error: Invalid nginx configuration"
        # Restore backup if it exists
        if [[ -f /etc/nginx/sites-available/default.backup.* ]]; then
            latest_backup=$(ls -t /etc/nginx/sites-available/default.backup.* | head -n1)
            cp "$latest_backup" /etc/nginx/sites-available/default
            echo "Restored previous nginx configuration"
        fi
        exit 1
    fi
    
    echo ""
    echo "========================================"
    echo "       HARDENED SITE SETUP COMPLETE"
    echo "========================================"
    echo ""
    echo "Site Configuration:"
    echo "- URL: http://127.0.0.1 (localhost only)"
    echo "- Document root: /var/www/html"
    echo "- Serves only: index.html"
    echo "- Security: No directory traversal, no PHP, hardened headers"
    echo ""
    echo "Hidden Service Access:"
    echo "- Nginx hidden service available via Tor"
    echo "- Hidden service address: /var/lib/tor/nginx_hidden_service/hostname"
    echo ""
    echo "Security Features:"
    echo "- Localhost only binding (127.0.0.1:80)"
    echo "- Directory traversal protection"
    echo "- PHP execution blocked"
    echo "- Security headers enabled"
    echo "- Only index.html accessible"
    echo "- All other requests return 404"
    echo ""
    echo "Test the site:"
    echo "- Local: curl http://127.0.0.1"
    echo "- Via Tor: curl --socks5-hostname 127.0.0.1:9050 http://\$(cat /var/lib/tor/nginx_hidden_service/hostname)"
    echo ""
    
    mark_step_completed 9
}

# ============================================================================
# MAIN EXECUTION LOGIC
# ============================================================================
# This section orchestrates the sequential execution of all setup steps
# Each step is evaluated by should_run_step() which considers:
#   - Current state file contents
#   - Command line arguments (--step, --continue)
#   - Dependency requirements

echo "Starting Debian 13 security setup..."
echo "Current state: Step $(get_last_completed_step) completed"

# STEP EXECUTION: Run each step if conditions are met
# The should_run_step() function handles all the logic for:
#   - Checking if step is already completed
#   - Validating dependencies 
#   - Respecting force and continue modes

# Step 1: System Updates (Foundation)
if should_run_step 1; then
    update
else
    echo "Skipping Step 1: update (already completed)"
fi

# Step 2: Package Installation (Security Tools)
if should_run_step 2; then
    packages
else
    echo "Skipping Step 2: packages (already completed)"
fi

# Step 3: Installation Verification (Quality Check)
if should_run_step 3; then
    verify
else
    echo "Skipping Step 3: verify (already completed)"
fi

# Step 4: User Account Creation (Privilege Separation)
if should_run_step 4; then
    user
else
    echo "Skipping Step 4: user (already completed)"
fi

# Step 5: SSH Key Authentication (Security Hardening)
# Note: This is the transition point - after step 5, user must connect via SSH
if should_run_step 5; then
    ssh
else
    echo "Skipping Step 5: ssh (already completed)"
fi

# Step 6: SSH Connection Verification (Validation)
# Must be run over SSH connection to prove key authentication works
if should_run_step 6; then
    verifyssh
else
    echo "Skipping Step 6: verifyssh (already completed)"
fi

# Step 7: WireGuard VPN Setup (Network Security)
# Provides selective VPN routing for enhanced privacy
if should_run_step 7; then
    wireguard
else
    echo "Skipping Step 7: wireguard (already completed)"
fi

# Step 8: Tor Proxy Configuration (Anonymous Browsing)
# Provides secure, anonymous web browsing through Tor network
if should_run_step 8; then
    tor
else
    echo "Skipping Step 8: tor (already completed)"
fi

# Step 9: Hardened Nginx Site (Demo Page)
# Provides hardened localhost web server with demo page
if should_run_step 9; then
    site
else
    echo "Skipping Step 9: site (already completed)"
fi

# COMPLETION SUMMARY: Show final status
echo "Setup process completed. Current state: Step $(get_last_completed_step) completed"

# ============================================================================
# SCRIPT COMPLETION
# ============================================================================
# At this point, the Debian 13 system should be fully secured with:
#   1. Updated system packages
#   2. Security tools installed (SSH, UFW, Tor, WireGuard, etc.)
#   3. Installation verified
#   4. Non-root user created with sudo privileges
#   5. SSH hardened with key-only authentication
#   6. SSH connection verified working
#   7. WireGuard VPN configured with selective routing
#   8. Tor proxy configured for anonymous browsing
#   9. Hardened nginx site with demo page
#
# The server is now ready for secure remote access, VPN connectivity, anonymous browsing, and web hosting.
